<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLB Viewer with Camera & Drawer UI</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    #cameraUI {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }
    .camera-btn {
      margin: 4px;
      padding: 6px 10px;
      font-size: 13px;
    }
    .toggle-btn {
      position: absolute;
      background: rgba(255,255,255,0.85);
      color: #000;
      padding: 3px 6px;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="cameraUI">
    <button class="camera-btn" onclick="switchCamera('view1')">Tampak Depan</button>
    <button class="camera-btn" onclick="switchCamera('view2')">Tampak Samping</button>
  </div>
  <div id="drawerToggle" class="toggle-btn" style="display:none;">Open</div>

  <script type="module">
    import * as THREE from './js/three.module.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    import { DRACOLoader } from './js/DRACOLoader.js';

    let scene, camera, renderer, controls, mixer;
    const clock = new THREE.Clock();
    const actions = {};
    let activeAction = null;
    let currentState = 'closed';
    let drawerToggle = document.getElementById("drawerToggle");
    let drawerObj, camList = {};

    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3, 2, 3);
    controls = new OrbitControls(camera, renderer.domElement);

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('./js/draco/');

    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);

    loader.load('untitled.glb', gltf => {
      const model = gltf.scene;
      scene.add(model);
      mixer = new THREE.AnimationMixer(model);

      // Gunakan light dari Blender, jangan override
      gltf.parser.getDependencies('light').then(lights => {
        lights.forEach(light => scene.add(light));
      });

      // Kamera bawaan Blender
      gltf.cameras?.forEach(cam => {
        if (cam.name) camList[cam.name] = cam;
      });

      // Object drawer
      drawerObj = model.getObjectByName('Drawer') || model;

      // Simpan animasi
      gltf.animations.forEach(clip => {
        const action = mixer.clipAction(clip);
        action.clampWhenFinished = true;
        action.setLoop(THREE.LoopOnce);
        actions[clip.name.toLowerCase()] = action;
      });
    });

    drawerToggle.addEventListener('click', () => {
      if (currentState === 'closed') {
        playAction('opendrawer');
        drawerToggle.innerText = 'Close';
        currentState = 'open';
      } else {
        playAction('closedrawer');
        drawerToggle.innerText = 'Open';
        currentState = 'closed';
      }
    });

    function playAction(name) {
      name = name.toLowerCase();
      if (!actions[name]) return;
      if (activeAction) activeAction.stop();
      activeAction = actions[name];
      activeAction.reset().play();
    }

    function switchCamera(name) {
      if (camList[name]) {
        camera.position.copy(camList[name].position);
        camera.quaternion.copy(camList[name].quaternion);
      }
    }

    function updateUIPosition() {
      if (!drawerObj) return;
      const dist = camera.position.distanceTo(drawerObj.position);
      if (dist < 2.5) {
        const vector = drawerObj.position.clone();
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        drawerToggle.style.left = `${x - 25}px`;
        drawerToggle.style.top = `${y - 15}px`;
        drawerToggle.style.display = 'block';
      } else {
        drawerToggle.style.display = 'none';
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      controls.update();
      updateUIPosition();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
