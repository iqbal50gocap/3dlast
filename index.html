<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLB Viewer with Camera & Drawer UI</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; background: #000; }
    #cameraButtons {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.7); color: white;
      padding: 10px; border-radius: 5px;
    }
    #drawerButtons {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      flex-direction: row;
      gap: 10px;
      z-index: 10;
    }
    #drawerButtons button {
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.9);
      color: black;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #brightnessControl {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 6px;
      color: white;
      font-size: 14px;
    }
    #brightnessControl input {
      vertical-align: middle;
    }
  </style>
</head>
<body>
  <div id="cameraButtons"></div>
  <div id="brightnessControl">
    Brightness:
    <input type="range" id="brightnessSlider" min="0" max="2" step="0.01" value="1">
  </div>
  <div id="drawerButtons">
    <button onclick="playAnim('opendrawer')">Open</button>
    <button onclick="playAnim('closedrawer')">Close</button>
  </div>
  <script type="module">
    import * as THREE from './js/three.module.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    import { DRACOLoader } from './js/DRACOLoader.js';
    import { OrbitControls } from './js/OrbitControls.js';

    let camera, scene, renderer, controls, mixer, clock = new THREE.Clock();
    let animations = {}, cameraList = [], currentCamera;
    let drawerObject = null;
    let lightIntensity = 1;

    const drawerButtons = document.getElementById('drawerButtons');

    init();

    function init() {
      scene = new THREE.Scene();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
      camera.position.set(2, 1.5, 2);

      controls = new OrbitControls(camera, renderer.domElement);

      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('./js/draco/');

      const loader = new GLTFLoader();
      loader.setDRACOLoader(dracoLoader);

      loader.load('untitled.glb', (gltf) => {
        const model = gltf.scene;
        scene.add(model);

        // Light from Blender
        renderer.physicallyCorrectLights = true;
        model.traverse(obj => {
          if (obj.isLight) {
            obj.intensity *= lightIntensity;
          }
        });

        // Animations
        mixer = new THREE.AnimationMixer(model);
        gltf.animations.forEach(clip => {
          animations[clip.name] = clip;
        });

        // Cameras
        gltf.cameras?.forEach((cam, i) => {
          cameraList.push(cam);
        });
        createCameraButtons();

        // Find drawer object
        drawerObject = model.getObjectByName('drawer') || model;

        // Force update brightness after initial load
        document.getElementById('brightnessSlider').dispatchEvent(new Event('input'));
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      document.getElementById('brightnessSlider').addEventListener('input', e => {
        lightIntensity = parseFloat(e.target.value);
        scene.traverse(obj => {
          if (obj.isLight) {
            obj.intensity = lightIntensity;
          }
        });
      });

      animate();
    }

    function createCameraButtons() {
      const btnContainer = document.getElementById('cameraButtons');
      btnContainer.innerHTML = '';
      cameraList.forEach((cam, idx) => {
        const btn = document.createElement('button');
        btn.innerText = cam.name || `Camera ${idx+1}`;
        btn.onclick = () => {
          currentCamera = cam;
          controls.object = currentCamera;
          controls.update();
        };
        btnContainer.appendChild(btn);
      });
    }

    window.playAnim = function(name) {
      if (animations[name]) {
        mixer.stopAllAction();
        mixer.clipAction(animations[name]).reset().play();
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      mixer?.update(dt);

      // Show/hide drawer UI if near
      if (drawerObject) {
        const distance = camera.position.distanceTo(drawerObject.getWorldPosition(new THREE.Vector3()));
        drawerButtons.style.display = distance < 2 ? 'flex' : 'none';
      }

      renderer.render(scene, currentCamera || camera);
    }
  </script>
</body>
</html>
