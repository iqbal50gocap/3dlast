<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D FPS Viewer (Solid Collisions + Model Switcher)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #instructions {
      position: absolute; top: 40%; width: 100%;
      text-align: center; color: white; font-size: 24px;
      z-index: 10; font-family: sans-serif;
    }
    #upload {
      position: absolute; top: 10px; left: 10px; z-index: 20;
      color: white;
    }
  </style>
</head>
<body>
  <div id="instructions">Click to Start</div>
  <input type="file" id="upload" accept=".glb,.gltf">
  <script type="module">
    import * as THREE from './js/three.module.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    import { PointerLockControls } from './js/PointerLockControls.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 10); // Start position adjusted slightly

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, document.body);
    document.getElementById('instructions').addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => document.getElementById('instructions').style.display = 'none');
    controls.addEventListener('unlock', () => document.getElementById('instructions').style.display = '');

    scene.add(controls.getObject());

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const gui = new GUI();
    const lightFolder = gui.addFolder('Lighting');
    lightFolder.add(dirLight, 'intensity', 0, 5).name('Directional Light');
    lightFolder.add(hemiLight, 'intensity', 0, 5).name('Hemisphere Light');
    lightFolder.open();

    const loader = new GLTFLoader();
    let worldCollidables = [];
    let currentModel = null;

    // Player collision parameters
    const playerRadius = 0.5; // Radius of the player capsule/sphere for collision
    const playerHeight = 1.6; // Height of the camera in the player object

    function loadGLBFromURL(url) {
      if (currentModel) scene.remove(currentModel);
      worldCollidables = []; // Clear previous collidables

      loader.load(url, gltf => {
        gltf.scene.position.set(0, 0, -10); // Position the loaded model
        currentModel = gltf.scene;
        scene.add(currentModel);

        gltf.scene.traverse(obj => {
          if (obj.isMesh) {
            // For simple collision, we'll use the mesh directly as a collidable
            // In a more complex game, you might use simplified collision meshes
            worldCollidables.push(obj);
          }
        });
      }, undefined, error => {
        console.error('Error loading GLB/GLTF model:', error);
      });
    }

    document.getElementById('upload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      loadGLBFromURL(url);
    });

    loadGLBFromURL('model.glb'); // default model

    const move = { forward: false, backward: false, left: false, right: false };
    const velocity = new THREE.Vector3();
    let canJump = true;
    const playerSpeed = 10.0; // Adjust for desired movement speed
    const gravity = 9.8 * 5.0; // Gravity strength
    const jumpPower = 5; // Jump height

    document.addEventListener('keydown', e => {
      if (!controls.isLocked) return; // Only process input if controls are locked

      switch (e.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
        case 'Space':
          if (canJump) {
            velocity.y = jumpPower; // Set jump velocity
            canJump = false;
          }
          break;
      }
    });

    document.addEventListener('keyup', e => {
      if (!controls.isLocked) return; // Only process input if controls are locked

      switch (e.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
      }
    });

    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const downVector = new THREE.Vector3(0, -1, 0); // For checking ground collision

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Apply friction/drag to horizontal velocity
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      // Apply gravity
      velocity.y -= gravity * delta;

      // Calculate desired movement direction
      const inputDirection = new THREE.Vector3();
      if (move.forward) inputDirection.z -= 1;
      if (move.backward) inputDirection.z += 1;
      if (move.left) inputDirection.x -= 1;
      if (move.right) inputDirection.x += 1;
      inputDirection.normalize(); // Normalize to prevent faster diagonal movement

      // Apply speed based on input
      if (move.forward || move.backward || move.left || move.right) {
          // Get the camera's forward and right vectors
          const forward = new THREE.Vector3();
          controls.getDirection(forward);
          forward.y = 0; // Keep horizontal
          forward.normalize();

          const right = new THREE.Vector3();
          right.crossVectors(camera.up, forward);
          right.y = 0; // Keep horizontal
          right.normalize();

          // Calculate movement based on camera's orientation
          const moveX = right.x * inputDirection.x + forward.x * inputDirection.z;
          const moveZ = right.z * inputDirection.x + forward.z * inputDirection.z;

          velocity.x = moveX * playerSpeed;
          velocity.z = moveZ * playerSpeed;
      }

      // Store current player position
      const prevPosition = controls.getObject().position.clone();

      // Apply movement based on velocity
      controls.moveRight(velocity.x * delta);
      controls.moveForward(velocity.z * delta);
      controls.getObject().position.y += velocity.y * delta;

      // Basic collision detection
      const playerPos = controls.getObject().position.clone();

      // Check for ground collision (always from slightly above the feet)
      raycaster.set(new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z), downVector);
      raycaster.far = playerHeight; // Check only for a short distance below the player
      const intersectsGround = raycaster.intersectObjects(worldCollidables, true);

      if (intersectsGround.length > 0) {
        const intersection = intersectsGround[0];
        // If falling and hit the ground, stop falling and place player on top
        if (velocity.y < 0) {
          controls.getObject().position.y = intersection.point.y + playerHeight;
          velocity.y = 0;
          canJump = true;
        }
      } else if (controls.getObject().position.y < playerHeight) { // Fall through if no ground collision
        // This is a fallback if the raycaster doesn't catch the ground, e.g., if the ground is very thin
        controls.getObject().position.y = playerHeight;
        velocity.y = 0;
        canJump = true;
      }

      // Check for horizontal collisions (simplistic, can be improved with multiple rays or a bounding box)
      // This is a very basic "push back" collision.
      // For more robust collision, you'd calculate the collision normal and slide along it.
      const currentMoveVec = controls.getObject().position.clone().sub(prevPosition);
      if (currentMoveVec.lengthSq() > 0) { // Only check if player actually moved
          const collisionRayOrigin = new THREE.Vector3(playerPos.x, playerPos.y - playerHeight / 2, playerPos.z);
          const collisionRayDir = currentMoveVec.normalize();
          raycaster.set(collisionRayOrigin, collisionRayDir);
          raycaster.far = playerRadius + currentMoveVec.length(); // Check a bit further than the actual movement
          const intersectsWalls = raycaster.intersectObjects(worldCollidables, true);

          if (intersectsWalls.length > 0 && intersectsWalls[0].distance < currentMoveVec.length() + playerRadius) {
            // Collision detected, revert position
            controls.getObject().position.copy(prevPosition);
            velocity.x = 0;
            velocity.z = 0;
          }
      }

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
