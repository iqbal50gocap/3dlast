<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D FPS GLB Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
    #instructions {
      position: absolute;
      top: 50%;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 24px;
      z-index: 10;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
    }
    input[type="file"], select, input[type="range"] {
      background: #111;
      color: white;
      border: 1px solid #555;
      padding: 4px;
      border-radius: 4px;
      margin-top: 4px;
    }
  </style>
</head>
<body>

<div id="instructions">Klik untuk mulai bergerak (FPS Mode)</div>
<div id="ui">
  <label>Ganti Map:
    <input type="file" id="fileUpload" accept=".glb" />
  </label><br><br>

  <label><input type="checkbox" id="gravityToggle" checked /> Gravity</label><br><br>

  <label>Lighting Preset:
    <select id="lightPreset">
      <option value="day">Siang</option>
      <option value="night">Malam</option>
      <option value="custom">Custom</option>
    </select>
  </label><br>

  <div id="customLight" style="display: none;">
    <label>Directional Light:
      <input type="range" id="dirLight" min="0" max="2" step="0.1" value="1" />
    </label><br>
    <label>Ambient Light:
      <input type="range" id="ambLight" min="0" max="2" step="0.1" value="0.4" />
    </label>
  </div>
</div>

<script type="module">
  import * as THREE from './js/three.module.js';
  import { GLTFLoader } from './js/GLTFLoader.js';
  import { PointerLockControls } from './js/PointerLockControls.js';

  let camera, scene, renderer, controls;
  let miniCamera;
  let velocity = new THREE.Vector3();
  let direction = new THREE.Vector3();
  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
  let canJump = false;
  let gravityEnabled = true;
  const objects = [];
  let currentModel;
  let dirLight, ambLight;

  init();
  animate();

  function init() {
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    ambLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambLight);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new PointerLockControls(camera, document.body);
    document.getElementById('instructions').addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => document.getElementById('instructions').style.display = 'none');
    controls.addEventListener('unlock', () => document.getElementById('instructions').style.display = '');

    scene.add(controls.getObject());

    document.addEventListener('keydown', (e) => handleKey(e, true));
    document.addEventListener('keyup', (e) => handleKey(e, false));

    document.getElementById('fileUpload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) loadModel(URL.createObjectURL(file));
    });

    document.getElementById('gravityToggle').addEventListener('change', (e) => {
      gravityEnabled = e.target.checked;
    });

    document.getElementById('lightPreset').addEventListener('change', (e) => {
      const value = e.target.value;
      const customUI = document.getElementById('customLight');
      if (value === 'custom') {
        customUI.style.display = 'block';
      } else {
        customUI.style.display = 'none';
        applyLightPreset(value);
      }
    });

    document.getElementById('dirLight').addEventListener('input', (e) => {
      dirLight.intensity = parseFloat(e.target.value);
    });

    document.getElementById('ambLight').addEventListener('input', (e) => {
      ambLight.intensity = parseFloat(e.target.value);
    });

    miniCamera = new THREE.OrthographicCamera(-50, 50, 50, -50, 0.1, 500);
    miniCamera.position.set(0, 100, 0);
    miniCamera.lookAt(0, 0, 0);

    window.addEventListener('resize', onWindowResize);
    loadModel('model.glb');
  }

  function handleKey(event, down) {
    switch (event.code) {
      case 'KeyW': moveForward = down; break;
      case 'KeyS': moveBackward = down; break;
      case 'KeyA': moveLeft = down; break;
      case 'KeyD': moveRight = down; break;
      case 'Space':
        if (down && canJump) {
          velocity.y += 5;
          canJump = false;
        }
        break;
    }
  }

  function loadModel(path) {
    const loader = new GLTFLoader();
    loader.load(path, (gltf) => {
      if (currentModel) {
        scene.remove(currentModel);
        objects.length = 0;
      }
      currentModel = gltf.scene;
      scene.add(currentModel);
      gltf.scene.traverse((child) => {
        if (child.isMesh) {
          child.geometry.computeBoundingBox();
          child.updateMatrixWorld();
          objects.push(child);
        }
      });
    });
  }

  function applyLightPreset(preset) {
    if (preset === 'day') {
      dirLight.intensity = 1;
      ambLight.intensity = 0.4;
      scene.background = new THREE.Color(0xaec6cf);
    } else if (preset === 'night') {
      dirLight.intensity = 0.2;
      ambLight.intensity = 0.1;
      scene.background = new THREE.Color(0x000011);
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);

    const delta = 0.1;
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;
    if (gravityEnabled) velocity.y -= 9.8 * 5.0 * delta;

    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize();

    const oldPosition = controls.getObject().position.clone();

    if (moveForward || moveBackward) velocity.z -= direction.z * 50.0 * delta;
    if (moveLeft || moveRight) velocity.x -= direction.x * 50.0 * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);
    controls.getObject().position.y += velocity.y * delta;

    // Collision
    const playerBox = new THREE.Box3().setFromCenterAndSize(
      controls.getObject().position,
      new THREE.Vector3(1, 2, 1)
    );

    for (let i = 0; i < objects.length; i++) {
      const object = objects[i];
      const objectBox = new THREE.Box3().setFromObject(object);
      if (playerBox.intersectsBox(objectBox)) {
        controls.getObject().position.copy(oldPosition);
        velocity.x = 0;
        velocity.z = 0;
        break;
      }
    }

    // Ground check
    if (controls.getObject().position.y < 1.5) {
      velocity.y = 0;
      controls.getObject().position.y = 1.5;
      canJump = true;
    }

    // Render main view
    renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);

    // Mini-map render
    renderer.clearDepth();
    renderer.setScissorTest(true);
    const size = 200;
    renderer.setScissor(window.innerWidth - size - 10, 10, size, size);
    renderer.setViewport(window.innerWidth - size - 10, 10, size, size);
    miniCamera.position.x = controls.getObject().position.x;
    miniCamera.position.z = controls.getObject().position.z;
    miniCamera.updateProjectionMatrix();
    renderer.render(scene, miniCamera);
    renderer.setScissorTest(false);
  }
</script>
</body>
</html>
